name: "Build MaisonGPT Desktop (macOS & Windows)"

on:
  push:
    tags:
      - "v*"
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      url:
        description: "Web app URL to package"
        type: string
        required: true
        default: "https://chat.maisonrmi.com"
      name:
        description: "Application name"
        type: string
        required: true
        default: "MaisonGPT"
      icon:
        description: "Path or URL to icon (PNG/ICO/ICNS). If omitted, Pake auto-fetches site icon."
        type: string
        required: false
        default: "assets/icons/logo-1024-white.png"

jobs:
  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [macos-latest, windows-latest]

    env:
      # Defaults for manual runs; on tag pushes, we compute version below
      INPUT_URL:  ${{ inputs.url || 'https://chat.maisonrmi.com' }}
      INPUT_NAME: ${{ inputs.name || 'MaisonGPT' }}
      INPUT_ICON: ${{ inputs.icon || 'assets/icons/logo-1024-white.png' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node (22.x)
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Set up Rust (stable)
        uses: dtolnay/rust-toolchain@stable

      - name: Compute app version from tag (if present)
        id: ver
        shell: bash
        run: |
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            RAW="${GITHUB_REF_NAME}"
            # strip leading 'v' if present (v1.2.3 -> 1.2.3)
            CLEAN="${RAW#v}"
            echo "app_version=$CLEAN" >> "$GITHUB_OUTPUT"
          else
            echo "app_version=1.0.0" >> "$GITHUB_OUTPUT"
          fi

      - name: Install Pake CLI (prebuilt)
        # As per docs: npm install -g pake-cli (pnpm also supported)
        run: npm install -g pake-cli

      - name: Install Tauri CLI (force latest)
        shell: bash
        run: |
          # Ensure we use the latest Tauri CLI to align with APIs.
          cargo install tauri-cli --locked --force
          tauri --version || true

      - name: Show environment
        shell: bash
        run: |
          node -v
          npm -v
          rustc -V
          pake --help | head -n 20 || true
          tauri --help | head -n 20 || true

      - name: Build with Pake
        shell: bash
        env:
          TAURI_CLI_NO_ERROR_ON_VERSION_MISMATCH: "true"
          TAURI_IGNORE_VERSION_MISMATCH: "true"
          TAURI_NO_ERROR_ON_VERSION_MISMATCH: "true"
          TAURI_SKIP_VERSION_CHECK: "true"
          NO_ERROR_ON_VERSION_MISMATCH: "true"
        run: |
          # Build only the target format for the current OS.
          if [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            TARGETS="dmg"
          else
            TARGETS="msi"
          fi
          pake "${INPUT_URL}" \
            --name "${INPUT_NAME}" \
            --title "${INPUT_NAME}" \
            --icon "${INPUT_ICON}" \
            --app-version "${{ steps.ver.outputs.app_version }}" \
            --targets "${TARGETS}"

      - name: Locate output artifact
        id: out
        shell: bash
        run: |
          # Be robust across Pake versions/paths and OS differences.
          if [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            # Prefer exact name then fallback glob
            if [[ -f "./${INPUT_NAME}.dmg" ]]; then
              echo "path=./${INPUT_NAME}.dmg" >> "$GITHUB_OUTPUT"
            else
              f=$(find . -maxdepth 4 -type f -name "*.dmg" | head -n 1)
              [[ -z "$f" ]] && { echo "No DMG found"; exit 1; }
              echo "path=$f" >> "$GITHUB_OUTPUT"
            fi
          else
            # Windows: look for MSI first (installer), else EXE/binary if keep-binary enabled
            f=$(find . -maxdepth 8 -type f \( -name "*.msi" -o -name "*.exe" \) | head -n 1)
            [[ -z "$f" ]] && { echo "No MSI/EXE found"; exit 1; }
            echo "path=$f" >> "$GITHUB_OUTPUT"
          fi
          echo "Found artifact: $(cat $GITHUB_OUTPUT)"

      - name: Upload workflow artifact (manual runs)
        if: ${{ github.event_name == 'workflow_dispatch' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.name || 'MaisonGPT' }}-${{ matrix.os }}
          path: ${{ steps.out.outputs.path }}
          if-no-files-found: error
          retention-days: 14

      - name: Upload build artifact for release (tag builds)
        if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/') }}
        uses: actions/upload-artifact@v4
        with:
          name: release-bundles-${{ matrix.os }}
          path: ${{ steps.out.outputs.path }}
          if-no-files-found: error
          retention-days: 3

      - name: Cleanup workspace
        if: always()
        shell: bash
        run: |
          # Keep the repo clean; runners are ephemeral but we tidy up to save space.
          rm -rf ./src-tauri/target || true
          find . -name "*.app" -o -name "*.dmg" -o -name "*.msi" -o -name "*.exe" | xargs -I{} rm -f "{}" || true

  release:
    # Only run on tag pushes; collects artifacts from all OS jobs and publishes a release
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/') }}
    needs: [build]
    runs-on: ubuntu-latest
    permissions:
      contents: write   # needed to create/update releases
    steps:
      - name: Download artifacts from all platforms
        uses: actions/download-artifact@v4
        with:
          pattern: release-bundles-*
          merge-multiple: true
          path: dist

      - name: List gathered files
        run: ls -R dist

      - name: Create/Update GitHub Release and upload assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: ${{ github.ref_name }}
          draft: false
          prerelease: false
          files: |
            dist/*.dmg
            dist/*.msi
            dist/*.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}